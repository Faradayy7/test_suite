const { test, expect } = require("@playwright/test");
const { ApiClient } = require("../../utils/api-client.js");
const { Logger } = require("../../utils/logger.js");
const { TestDataManager } = require("../../utils/test-data-manager.js");

const logger = new Logger("cupones-negative-tests");
const testDataManager = new TestDataManager();

// Helper function para logging detallado de respuestas en tests negativos
function logNegativeResponseDetails(
  response,
  expectedStatus,
  expectedDataStatus,
  testName = ""
) {
  const actualStatus = response.status;
  const actualDataStatus = response.data?.status || "N/A";

  logger.info(
    `üîç ${testName} - Status HTTP: ${actualStatus}, Data Status: ${actualDataStatus}`
  );

  if (actualStatus !== expectedStatus) {
    logger.info(
      `‚ö†Ô∏è Status inesperado: Esperaba ${expectedStatus}, recibi√≥ ${actualStatus}`
    );
  }

  if (actualDataStatus !== expectedDataStatus && expectedDataStatus !== "N/A") {
    logger.info(
      `‚ö†Ô∏è Data Status inesperado: Esperaba '${expectedDataStatus}', recibi√≥ '${actualDataStatus}'`
    );
  }

  // Log del mensaje de error si existe
  if (response.data?.data) {
    logger.info(`üìù Mensaje de error: ${response.data.data}`);
  }

  return { actualStatus, actualDataStatus };
}

test.describe("üö´ Tests Negativos - API Cupones", () => {
  let extractedGroupIds = [];
  let existingCouponCodes = [];

  test.beforeAll(async ({ request }) => {
    logger.info("üö´ Iniciando suite de tests negativos para API Cupones");
    const apiClient = new ApiClient(request);

    // Obtener datos reales del sistema para usar en tests negativos
    const response = await apiClient.get("/api/coupon", {
      limit: 50,
      offset: 0,
    });

    if (response.status === 200 && response.data.status === "OK") {
      testDataManager.processCouponsData(response.data);

      // Extraer Group IDs reales para usar en tests
      const rawGroupIds = testDataManager.getAllGroupIds();
      extractedGroupIds = rawGroupIds.map((groupObj) => {
        return typeof groupObj === "object" && groupObj._id
          ? groupObj._id
          : groupObj;
      });

      // Extraer c√≥digos existentes para tests
      existingCouponCodes = testDataManager.getAllCouponCodes();

      logger.info(
        `‚úÖ ${extractedGroupIds.length} Group IDs obtenidos para tests negativos`
      );
      logger.info(
        `üìä ${existingCouponCodes.length} c√≥digos de cupones existentes en el sistema`
      );
    } else {
      logger.info("‚ùå Error obteniendo datos iniciales para tests negativos");
    }
  });

  // ==================== TESTS DE CREACI√ìN NEGATIVA ====================

  test("TC-NEG-001: POST /api/coupon - Error al crear cup√≥n con c√≥digo duplicado (reutilizable)", async ({
    request,
  }) => {
    logger.info(
      "üß™ Test Negativo: Error al crear cup√≥n reutilizable con c√≥digo duplicado"
    );

    const apiClient = new ApiClient(request);
    const testCouponsToCleanup = []; // Fixtures para este test

    try {
      // Validar datos necesarios
      if (extractedGroupIds.length === 0) {
        logger.info("‚ö†Ô∏è No hay Group IDs disponibles, saltando test");
        test.skip();
        return;
      }

      const groupId = extractedGroupIds[0];
      const testCode = `DUPLICATE_TEST_${Date.now()}`;

      // Paso 1: Crear cup√≥n inicial
      const initialCouponData = {
        group: groupId,
        valid_from: "2025-08-01T08:00:00Z",
        valid_to: "2025-08-31T23:59:59Z",
        is_reusable: "true",
        max_use: "5",
        customer_max_use: "2",
        custom_code: testCode,
        detail: "Test Negativo - Cup√≥n Inicial",
        quantity: "1",
        discount_type: "percent",
        percent: "10",
        type: "ppv-live",
        type_code: "neg_test_initial",
        payment_required: "false",
      };

      logger.info(`üéØ Creando cup√≥n inicial con c√≥digo: ${testCode}`);
      const initialResponse = await apiClient.post(
        "/api/coupon",
        initialCouponData
      );

      expect(initialResponse.status).toBe(200);
      expect(initialResponse.data.status).toBe("OK");

      const createdCoupon = initialResponse.data.data[0];
      testCouponsToCleanup.push(createdCoupon._id); // Agregar a fixtures para cleanup

      logger.info(
        `‚úÖ Cup√≥n inicial creado: ${createdCoupon.code} (ID: ${createdCoupon._id})`
      );

      // Paso 2: Intentar crear otro cup√≥n con el mismo c√≥digo
      const duplicateCouponData = {
        group: groupId,
        valid_from: "2025-08-01T08:00:00Z",
        valid_to: "2025-08-31T23:59:59Z",
        is_reusable: "true",
        max_use: "3",
        customer_max_use: "1",
        custom_code: testCode, // Usar c√≥digo duplicado
        detail: "Test Negativo - Intento de Duplicaci√≥n",
        quantity: "1",
        discount_type: "percent",
        percent: "5",
        type: "ppv-live",
        type_code: "neg_test_duplicate",
        payment_required: "false",
      };

      logger.info(
        `üéØ Intentando crear cup√≥n duplicado con c√≥digo: ${testCode}`
      );
      const duplicateResponse = await apiClient.post(
        "/api/coupon",
        duplicateCouponData
      );

      // Log detallado de la respuesta
      logNegativeResponseDetails(
        duplicateResponse,
        400,
        "ERROR",
        "POST /api/coupon (c√≥digo duplicado)"
      );

      // Validar que la API rechaza el c√≥digo duplicado
      expect(duplicateResponse.status).toBe(400);
      expect(duplicateResponse.data.status).toBe("ERROR");
      expect(duplicateResponse.data.data).toBeDefined();
      expect(duplicateResponse.data.data).toBe("COUPON_CODE_ALREADY_EXISTS");

      logger.info(`‚úÖ ERROR ESPERADO: ${duplicateResponse.data.data}`);
      logger.info(
        "üîí VALIDACI√ìN EXITOSA: Los c√≥digos duplicados se rechazan correctamente en cupones reutilizables"
      );
    } finally {
      // CLEANUP: Limpiar fixtures creadas en este test
      for (const couponId of testCouponsToCleanup) {
        try {
          await apiClient.delete(`/api/coupon/${couponId}`);
          logger.info(`üßπ Fixture eliminada: ${couponId}`);
        } catch (error) {
          logger.info(
            `‚ö†Ô∏è Error limpiando fixture ${couponId}: ${error.message}`
          );
        }
      }
    }
  });

  test("TC-NEG-002: POST /api/coupon - Comportamiento con c√≥digo duplicado en cup√≥n no reutilizable", async ({
    request,
  }) => {
    logger.info(
      "üß™ Test Negativo: Comportamiento especial con c√≥digo duplicado en cup√≥n no reutilizable"
    );

    const apiClient = new ApiClient(request);
    const testCouponsToCleanup = []; // Fixtures para este test

    try {
      // Usar c√≥digos existentes del sistema
      if (existingCouponCodes.length === 0 || extractedGroupIds.length === 0) {
        logger.info("‚ö†Ô∏è No hay datos suficientes, saltando test");
        test.skip();
        return;
      }

      const existingCode = existingCouponCodes[0]; // C√≥digo que ya existe en el sistema
      const groupId = extractedGroupIds[0];

      const nonReusableCouponData = {
        group: groupId,
        valid_from: "2025-08-01T08:00:00Z",
        valid_to: "2025-08-31T23:59:59Z",
        is_reusable: "false", // NO REUTILIZABLE
        max_use: "1",
        customer_max_use: "1",
        custom_code: existingCode, // Usar c√≥digo que YA EXISTE
        detail: "Test Negativo - Cup√≥n No Reutilizable con C√≥digo Existente",
        quantity: "1",
        discount_type: "percent",
        percent: "15",
        type: "ppv-live",
        type_code: "neg_test_non_reusable",
        payment_required: "false",
      };

      logger.info(
        `üéØ Intentando crear cup√≥n NO REUTILIZABLE con c√≥digo existente: ${existingCode}`
      );
      logger.info(
        "‚ö†Ô∏è COMPORTAMIENTO ESPERADO: El sistema deber√≠a crear un cup√≥n con c√≥digo diferente (ignora el custom_code)"
      );

      const response = await apiClient.post(
        "/api/coupon",
        nonReusableCouponData
      );

      // Log detallado de la respuesta
      logNegativeResponseDetails(
        response,
        200,
        "OK",
        "POST /api/coupon (no reutilizable, c√≥digo existente)"
      );

      // VALIDACI√ìN ESPECIAL: Para cupones no reutilizables, el sistema NO genera error
      // sino que crea un nuevo cup√≥n con c√≥digo diferente para evitar duplicidad
      expect(response.status).toBe(200);
      expect(response.data.status).toBe("OK");
      expect(Array.isArray(response.data.data)).toBe(true);
      expect(response.data.data.length).toBeGreaterThan(0);

      const createdCoupon = response.data.data[0];
      testCouponsToCleanup.push(createdCoupon._id); // Agregar a fixtures para cleanup

      // VALIDACI√ìN CR√çTICA: El c√≥digo generado debe ser DIFERENTE al solicitado
      expect(createdCoupon.code).not.toBe(existingCode);
      expect(createdCoupon.code).toBeDefined();
      expect(typeof createdCoupon.code).toBe("string");

      logger.info(`‚úÖ COMPORTAMIENTO CORRECTO VALIDADO:`);
      logger.info(`   - C√≥digo solicitado: ${existingCode} (duplicado)`);
      logger.info(
        `   - C√≥digo generado: ${createdCoupon.code} (nuevo y √∫nico)`
      );
      logger.info(`   - ID del cup√≥n: ${createdCoupon._id}`);
      logger.info(
        "üîí VALIDACI√ìN EXITOSA: Para cupones NO REUTILIZABLES, el sistema ignora c√≥digos duplicados y genera uno nuevo"
      );
    } finally {
      // CLEANUP: Limpiar fixtures creadas en este test
      for (const couponId of testCouponsToCleanup) {
        try {
          await apiClient.delete(`/api/coupon/${couponId}`);
          logger.info(`üßπ Fixture eliminada: ${couponId}`);
        } catch (error) {
          logger.info(
            `‚ö†Ô∏è Error limpiando fixture ${couponId}: ${error.message}`
          );
        }
      }
    }
  });

  test("TC-NEG-003: POST /api/coupon - Error con datos inv√°lidos", async ({
    request,
  }) => {
    logger.info("üß™ Test Negativo: Error con datos inv√°lidos");

    const apiClient = new ApiClient(request);
    const testCouponsToCleanup = []; // Fixtures para este test (aunque no deber√≠a crear nada)

    try {
      const invalidCouponData = {
        group: "", // Group ID vac√≠o - deber√≠a causar error
        valid_from: "fecha-invalida", // Fecha mal formateada
        valid_to: "2025-08-31T23:59:59Z",
        is_reusable: "maybe", // Valor inv√°lido para boolean
        max_use: "-1", // Valor negativo
        customer_max_use: "texto", // No es n√∫mero
        custom_code: "INVALID CODE WITH SPACES AND SPECIAL CHARS!", // C√≥digo con espacios y caracteres especiales
        detail: "Test Negativo - Datos Inv√°lidos",
        quantity: "0", // Cantidad cero
        discount_type: "invalid_type", // Tipo de descuento inv√°lido
        amount: "not_a_number", // Monto no num√©rico
        percent: "150", // Porcentaje mayor a 100
        type: "", // Tipo vac√≠o
        type_code: "", // Type code vac√≠o
        payment_required: "not_boolean", // No es boolean
      };

      logger.info(
        "üéØ Enviando datos completamente inv√°lidos para validar manejo de errores"
      );

      const response = await apiClient.post("/api/coupon", invalidCouponData);

      // Log detallado para errores esperados
      logNegativeResponseDetails(
        response,
        [400, 500],
        "ERROR",
        "POST /api/coupon (datos inv√°lidos)"
      );

      // La API puede devolver 400 o 500 dependiendo del tipo de validaci√≥n
      expect([400, 500]).toContain(response.status);
      expect(response.data.status).toBe("ERROR");
      expect(response.data.data).toBeDefined();

      logger.info(
        `‚úÖ ERROR ESPERADO con datos inv√°lidos (${response.status}): ${
          response.data.data || "Validation Error"
        }`
      );
      logger.info(
        "üîí VALIDACI√ìN EXITOSA: El sistema rechaza correctamente datos inv√°lidos"
      );
    } finally {
      // CLEANUP: No deber√≠a haber fixtures que limpiar para este test
      // pero mantenemos la estructura consistente
      for (const couponId of testCouponsToCleanup) {
        try {
          await apiClient.delete(`/api/coupon/${couponId}`);
          logger.info(`üßπ Fixture eliminada: ${couponId}`);
        } catch (error) {
          logger.info(
            `‚ö†Ô∏è Error limpiando fixture ${couponId}: ${error.message}`
          );
        }
      }
    }
  });

  test("TC-NEG-004: POST /api/coupon - Error con Group ID inexistente", async ({
    request,
  }) => {
    logger.info("üß™ Test Negativo: Error con Group ID que no existe");

    const apiClient = new ApiClient(request);
    const testCouponsToCleanup = []; // Fixtures para este test (aunque no deber√≠a crear nada)

    try {
      const nonExistentGroupId = "000000000000000000000000"; // ID que no existe

      const couponDataWithInvalidGroup = {
        group: nonExistentGroupId,
        valid_from: "2025-08-01T08:00:00Z",
        valid_to: "2025-08-31T23:59:59Z",
        is_reusable: "true",
        max_use: "5",
        customer_max_use: "2",
        detail: "Test Negativo - Group ID Inexistente",
        quantity: "1",
        discount_type: "percent",
        percent: "10",
        type: "ppv-live",
        type_code: "neg_test_invalid_group",
        payment_required: "false",
      };

      logger.info(
        `üéØ Intentando crear cup√≥n con Group ID inexistente: ${nonExistentGroupId}`
      );

      const response = await apiClient.post(
        "/api/coupon",
        couponDataWithInvalidGroup
      );

      logNegativeResponseDetails(
        response,
        [200, 400, 404],
        "ERROR",
        "POST /api/coupon (Group ID inexistente)"
      );

      // Validar que la API rechaza el Group ID inexistente (puede ser 200 con ERROR, 400 o 404)
      expect([200, 400, 404]).toContain(response.status);
      expect(response.data.status).toBe("ERROR");
      expect(response.data.data).toBeDefined();

      logger.info(
        `‚úÖ ERROR ESPERADO con Group ID inexistente: ${response.data.data}`
      );
      logger.info(
        "üîí VALIDACI√ìN EXITOSA: La API rechaza Group IDs que no existen"
      );
    } finally {
      // CLEANUP: No deber√≠a haber fixtures que limpiar para este test
      // pero mantenemos la estructura consistente
      for (const couponId of testCouponsToCleanup) {
        try {
          await apiClient.delete(`/api/coupon/${couponId}`);
          logger.info(`üßπ Fixture eliminada: ${couponId}`);
        } catch (error) {
          logger.info(
            `‚ö†Ô∏è Error limpiando fixture ${couponId}: ${error.message}`
          );
        }
      }
    }
  });

  // ==================== TESTS DE ACTUALIZACI√ìN NEGATIVA ====================

  test("TC-NEG-005: POST /api/coupon/{id} - Intento de actualizar con c√≥digo ya usado (comportamiento silencioso)", async ({
    request,
  }) => {
    logger.info(
      "üß™ Test Negativo: Actualizaci√≥n silenciosa al intentar usar c√≥digo duplicado"
    );

    const apiClient = new ApiClient(request);
    const testCouponsToCleanup = []; // Fixtures para este test

    try {
      // Verificar que tenemos datos necesarios
      if (existingCouponCodes.length === 0 || extractedGroupIds.length === 0) {
        logger.info("‚ö†Ô∏è No hay datos suficientes, saltando test");
        test.skip();
        return;
      }

      const groupId = extractedGroupIds[0];
      const existingCode = existingCouponCodes[0]; // C√≥digo que ya existe en el sistema

      // Paso 1: Crear un cup√≥n que vamos a intentar actualizar
      const initialCouponData = {
        group: groupId,
        valid_from: "2025-08-01T08:00:00Z",
        valid_to: "2025-08-31T23:59:59Z",
        is_reusable: "true",
        max_use: "5",
        customer_max_use: "2",
        custom_code: "UPDATE_TEST_ORIGINAL",
        detail: "Test de Actualizaci√≥n - Original",
        quantity: "1",
        discount_type: "percent",
        percent: "10",
        type: "ppv-live",
        type_code: "update_test_original",
        payment_required: "false",
      };

      logger.info("üéØ Creando cup√≥n para test de actualizaci√≥n");
      const createResponse = await apiClient.post(
        "/api/coupon",
        initialCouponData
      );

      expect(createResponse.status).toBe(200);
      expect(createResponse.data.status).toBe("OK");

      const createdCoupon = createResponse.data.data[0];
      testCouponsToCleanup.push(createdCoupon._id); // Agregar a fixtures para cleanup
      const originalCode = createdCoupon.code;

      logger.info(
        `‚úÖ Cup√≥n creado para actualizaci√≥n: ${originalCode} (ID: ${createdCoupon._id})`
      );

      // Paso 2: Intentar actualizar con c√≥digo existente
      const updateDataWithDuplicateCode = {
        group: groupId,
        valid_from: "2025-08-01T08:00:00Z",
        valid_to: "2025-09-30T23:59:59Z",
        is_reusable: "true",
        max_use: "5",
        customer_max_use: "2",
        custom_code: existingCode, // Intentar usar c√≥digo ya existente
        detail: "Test Negativo - Actualizaci√≥n con C√≥digo Duplicado",
        amount: "20",
        type: "ppv-live",
        type_code: "neg_test_update_duplicate",
        payment_required: "true",
      };

      logger.info(`üéØ Intentando actualizar cup√≥n ${createdCoupon._id}`);
      logger.info(`   - C√≥digo actual: ${originalCode}`);
      logger.info(
        `   - C√≥digo que se quiere usar: ${existingCode} (YA EXISTE en el sistema)`
      );
      logger.info(
        "‚ö†Ô∏è COMPORTAMIENTO ESPERADO: La API devuelve 200 OK pero mantiene el c√≥digo original"
      );

      const response = await apiClient.post(
        `/api/coupon/${createdCoupon._id}`,
        updateDataWithDuplicateCode
      );

      logNegativeResponseDetails(
        response,
        200,
        "OK",
        "POST /api/coupon/{id} (c√≥digo duplicado)"
      );

      // VALIDACI√ìN ESPECIAL: La API devuelve 200 OK pero NO actualiza el c√≥digo
      expect(response.status).toBe(200);
      expect(response.data.status).toBe("OK");
      expect(response.data.data).toBeDefined();

      const updatedCoupon = response.data.data;

      // VALIDACI√ìN CR√çTICA: El c√≥digo NO debe haber cambiado
      expect(updatedCoupon.code).toBe(originalCode);
      expect(updatedCoupon.code).not.toBe(existingCode);
      expect(updatedCoupon._id).toBe(createdCoupon._id);

      // Otras actualizaciones S√ç deben haberse aplicado
      expect(updatedCoupon.detail).toContain("C√≥digo Duplicado");
      expect(updatedCoupon.amount).toBe(20);

      logger.info(`‚úÖ COMPORTAMIENTO SILENCIOSO VALIDADO:`);
      logger.info(
        `   - C√≥digo solicitado: ${existingCode} (RECHAZADO silenciosamente)`
      );
      logger.info(
        `   - C√≥digo actual: ${updatedCoupon.code} (MANTUVO el original)`
      );
      logger.info(
        `   - Otras actualizaciones: S√ç se aplicaron (detail, amount, etc.)`
      );
      logger.info(
        "üîí VALIDACI√ìN EXITOSA: Los c√≥digos duplicados en actualizaciones se rechazan silenciosamente"
      );
    } finally {
      // CLEANUP: Limpiar fixtures creadas en este test
      for (const couponId of testCouponsToCleanup) {
        try {
          await apiClient.delete(`/api/coupon/${couponId}`);
          logger.info(`üßπ Fixture eliminada: ${couponId}`);
        } catch (error) {
          logger.info(
            `‚ö†Ô∏è Error limpiando fixture ${couponId}: ${error.message}`
          );
        }
      }
    }
  });

  // ==================== TESTS DE CONSULTA NEGATIVA ====================

  test("TC-NEG-006: GET /api/coupon/{id} - Error para cup√≥n inexistente", async ({
    request,
  }) => {
    logger.info("üß™ Test Negativo: Error para cup√≥n inexistente");

    const apiClient = new ApiClient(request);
    const testCouponsToCleanup = []; // Fixtures para este test (no habr√° ninguna)

    try {
      const nonExistentId = "000000000000000000000000"; // ID MongoDB que no existe

      logger.info(`üéØ Buscando cup√≥n inexistente con ID: ${nonExistentId}`);

      const response = await apiClient.get(`/api/coupon/${nonExistentId}`);

      logNegativeResponseDetails(
        response,
        200,
        "ERROR",
        "GET /api/coupon/{id} - cup√≥n inexistente"
      );

      // La API devuelve 200 con status ERROR y data null para recursos no encontrados
      expect(response.status).toBe(200);
      expect(response.data.status).toBe("ERROR");
      expect(response.data.data).toBe(null);

      logger.info("‚úÖ ERROR ESPERADO para cup√≥n inexistente: data = null");
      logger.info(
        "üîí VALIDACI√ìN EXITOSA: La API maneja correctamente cupones inexistentes"
      );
    } finally {
      // CLEANUP: No hay fixtures que limpiar para este test
      for (const couponId of testCouponsToCleanup) {
        try {
          await apiClient.delete(`/api/coupon/${couponId}`);
          logger.info(`üßπ Fixture eliminada: ${couponId}`);
        } catch (error) {
          logger.info(
            `‚ö†Ô∏è Error limpiando fixture ${couponId}: ${error.message}`
          );
        }
      }
    }
  });

  test("TC-NEG-007: GET /api/coupon/{code}/search - Error para c√≥digo inexistente", async ({
    request,
  }) => {
    logger.info("üß™ Test Negativo: Error para c√≥digo de cup√≥n inexistente");

    const apiClient = new ApiClient(request);
    const testCouponsToCleanup = []; // Fixtures para este test (no habr√° ninguna)

    try {
      const nonExistentCode = "CODIGO_QUE_NO_EXISTE_123";

      logger.info(
        `üéØ Buscando cup√≥n por c√≥digo inexistente: ${nonExistentCode}`
      );

      const response = await apiClient.get(
        `/api/coupon/${nonExistentCode}/search`
      );

      logNegativeResponseDetails(
        response,
        200,
        "ERROR",
        "GET /api/coupon/{code}/search - c√≥digo inexistente"
      );

      // La API devuelve 200 con status ERROR y data null para c√≥digos no encontrados
      expect(response.status).toBe(200);
      expect(response.data.status).toBe("ERROR");
      expect(response.data.data).toBe(null);

      logger.info("‚úÖ ERROR ESPERADO para c√≥digo inexistente: data = null");
      logger.info(
        "üîí VALIDACI√ìN EXITOSA: La API maneja correctamente c√≥digos inexistentes"
      );
    } finally {
      // CLEANUP: No hay fixtures que limpiar para este test
      for (const couponId of testCouponsToCleanup) {
        try {
          await apiClient.delete(`/api/coupon/${couponId}`);
          logger.info(`üßπ Fixture eliminada: ${couponId}`);
        } catch (error) {
          logger.info(
            `‚ö†Ô∏è Error limpiando fixture ${couponId}: ${error.message}`
          );
        }
      }
    }
  });

  test("TC-NEG-008: DELETE /api/coupon/{id} - Error para cup√≥n inexistente", async ({
    request,
  }) => {
    logger.info("üß™ Test Negativo: Error al eliminar cup√≥n inexistente");

    const apiClient = new ApiClient(request);
    const testCouponsToCleanup = []; // Fixtures para este test (no habr√° ninguna)

    try {
      const nonExistentId = "000000000000000000000000"; // ID MongoDB que no existe

      logger.info(
        `üéØ Intentando eliminar cup√≥n inexistente con ID: ${nonExistentId}`
      );

      const response = await apiClient.delete(`/api/coupon/${nonExistentId}`);

      logNegativeResponseDetails(
        response,
        [200, 404],
        "ERROR",
        "DELETE /api/coupon/{id} - cup√≥n inexistente"
      );

      // La API puede devolver 200 con ERROR o 404 directamente
      expect([200, 404]).toContain(response.status);

      if (response.status === 200) {
        expect(response.data.status).toBe("ERROR");
        expect(response.data.data).toBeDefined();
      }

      logger.info(
        `‚úÖ ERROR ESPERADO para eliminaci√≥n de cup√≥n inexistente (${response.status})`
      );
      logger.info(
        "üîí VALIDACI√ìN EXITOSA: La API maneja correctamente intentos de eliminar cupones inexistentes"
      );
    } finally {
      // CLEANUP: No hay fixtures que limpiar para este test
      for (const couponId of testCouponsToCleanup) {
        try {
          await apiClient.delete(`/api/coupon/${couponId}`);
          logger.info(`üßπ Fixture eliminada: ${couponId}`);
        } catch (error) {
          logger.info(
            `‚ö†Ô∏è Error limpiando fixture ${couponId}: ${error.message}`
          );
        }
      }
    }
  });
});
